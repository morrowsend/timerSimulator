let counter = 0;
let sawtoothWave = [];
let pwmWave = [];
let waveSpeed = 2;
let wavePosition = 0;
let waveFrequency = 100; // Maximum value for the 8-bit counter (255)
let pwmDutyCycle = 0.5; // 50% duty cycle for PWM
let prescaler = 1; // Prescaler to slow down the clock
let lastTickTime = 0; // Last time in milliseconds when the counter was updated
let tickInterval = 10; // Base time interval for each counter increment in milliseconds
let cmpVal = 50; //counter PWM compare value
let lastCycleTime = 0;
let wavelength = 0;
let frequencyHz = 0;
let pwmInverted = true; // New flag for PWM inversion

function setup() {
  createCanvas(windowWidth, windowHeight);
}

function draw() {
  background(220);
  tickInterval = 10 * prescaler;

  pwmDutyCycle = cmpVal / waveFrequency;

  // Split screen vertically (top for sawtooth, bottom for PWM)
  stroke(0);
  line(0, height / 2, width, height / 2);  // Horizontal line at the middle of the screen

  // Display current values and labels
  fill(0);
  textSize(16);
  textAlign(CENTER, TOP);
  text("Sawtooth Value: " + nf(counter, 0, 2), 10, 10);
  let pwmState = counter < pwmDutyCycle * waveFrequency;
  if (pwmInverted) pwmState = !pwmState;
  text("PWM Output Value: " + (pwmState ? "HIGH" : "LOW"), width / 2 + 10, height/2-20);
  text("Wavelength: " + nf(wavelength, 1, 1) + " ms  |  Frequency: " + nf(frequencyHz, 1, 2) + " Hz", width / 2, 30);

  // Top: Sawtooth wave plotting
  stroke(0);
  noFill();
  beginShape();
  for (let i = 0; i < sawtoothWave.length; i++) {
    let x = i;
    let y = sawtoothWave[i];
    vertex(x, y);
  }
  endShape();

  // Millisecond clock - control the counter update
  let currentMillis = millis();
  if (currentMillis - lastTickTime >= tickInterval) {
    lastTickTime = currentMillis;

    let sawtoothValue = map(counter, 0, 255, height / 2 - 50, 50);

    if (wavePosition < width) {
      sawtoothWave.push(sawtoothValue);
      let pwmVal = counter < cmpVal;
      if (pwmInverted) pwmVal = !pwmVal;
      pwmWave.push({ x: 10 + wavePosition, y: pwmVal ? height - 10 : height / 2 + 10 });
      wavePosition++;
    } else {
      sawtoothWave = [];
      pwmWave = [];
      wavePosition = 0;
    }

    counter++;
    if (counter > waveFrequency) {
      counter = 0;
      wavelength = currentMillis - lastCycleTime;
      frequencyHz = 1000 / wavelength;
      lastCycleTime = currentMillis;
    }
  }

  // Green line for Compare (correlating to PWM output value)
  stroke(0, 128, 0);
  let compareLineHeight = map(cmpVal, 0, 255, height / 2 - 50, 50);
  line(0, compareLineHeight, width, compareLineHeight);
  fill(0, 128, 0);
  textSize(14);
  textAlign(CENTER, CENTER);
  text("Compare = "+cmpVal, width / 2, compareLineHeight);

  // Red line for Max Counter at the peak of sawtooth
  stroke(139, 0, 0);
  let maxCounterHeight = map(waveFrequency, 0, 255, height / 2 - 50, 50);
  line(0, maxCounterHeight, width, maxCounterHeight);
  fill(139, 0, 0);
  textSize(14);
  textAlign(CENTER, CENTER);
  text("Max Counter = "+waveFrequency, width / 2, maxCounterHeight);

  // Blue line at the bottom of sawtooth's value (Counter Bottom = 0)
  stroke(0, 0, 139);
  let minCounterHeight = map(0, 0, 255, height / 2 - 50, 50);
  line(0, minCounterHeight, width, minCounterHeight);
  fill(0, 0, 139);
  textSize(14);
  textAlign(CENTER, CENTER);
  text("Counter Bottom = 0", width / 2, minCounterHeight);

  // Dark gray line showing where 255 would be
  stroke(100);
  let top255 = map(255, 0, 255, height / 2 - 50, 50);
  line(0, top255, width, top255);
  fill(100);
  textAlign(CENTER, CENTER);
  text("Counter Max (255)", width / 2, top255);

  // Bottom: PWM output representation
  stroke(0);
  noFill();
  beginShape();
  for (let i = 0; i < pwmWave.length; i++) {
    let p = pwmWave[i];
    vertex(p.x, p.y);
  }
  endShape();
}

function keyPressed() {
  if (key === 'W' || key === 'w') {
    waveFrequency = constrain(waveFrequency + 10, 20, 255);
    print("Wave Frequency = "+waveFrequency );
  } else if (key === 'S' || key === 's') {
    waveFrequency = constrain(waveFrequency - 10, 20, 255);
    print("Wave Frequency = "+waveFrequency );
  } else if (key === 'P' || key === 'p') {
    prescaler = constrain(prescaler <<1, 1, 255);
    print("prescaler = "+prescaler );
  } else if (key === 'O' || key === 'o') {
    prescaler = constrain(prescaler >>1, 1, 255);
    print("prescaler = "+prescaler );
  } else if (key === 'M' || key === 'm') {
    cmpVal = constrain(cmpVal + 10, 0, waveFrequency);
    print("New Compare Value = "+cmpVal+"\t Duty Cycle = "+pwmDutyCycle );
  } else if (key === 'N' || key === 'n') {
    cmpVal = constrain(cmpVal - 10, 0, waveFrequency);
    print("New Compare Value = "+cmpVal+"\t Duty Cycle = "+pwmDutyCycle );
  } else if (key === 'I' || key === 'i') {
    pwmInverted = !pwmInverted;
    print("PWM Inverted: "+pwmInverted);
  }
}